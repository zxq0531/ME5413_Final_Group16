#!/usr/bin/env python3
import rospy
import numpy as np
import math
from enum import Enum
from geometry_msgs.msg import Twist, PoseStamped, PoseWithCovarianceStamped
from nav_msgs.msg import Odometry, Path
import tf.transformations as tft
from NMPC_controller import AutonomousCarNMPC  

# Finite State Machine (FSM) states
class FSMState(Enum):
    IDLE = 0
    ROTATE_TO_TRAJECTORY = 1   # Rotate to align with the initial trajectory orientation
    MPC_TRACKING = 2           # Track the trajectory using NMPC
    ROTATE_TO_DEFAULT = 3      # Rotate to a default orientation at the end

# Simple PID controller for yaw alignment
class PIDController:
    def __init__(self, kp, ki, kd, max_output):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.max_output = max_output
        self.prev_error = 0.0
        self.integral = 0.0

    def compute(self, error, dt):
        self.integral += error * dt
        derivative = (error - self.prev_error) / dt if dt > 0 else 0.0
        output = self.kp * error + self.ki * self.integral + self.kd * derivative
        self.prev_error = error
        return max(min(output, self.max_output), -self.max_output)

# Convert quaternion to yaw angle
def quat_to_yaw(q):
    euler = tft.euler_from_quaternion([q.x, q.y, q.z, q.w])
    return euler[2]

# Convert a Pose message to a numpy array [x, y, yaw]
def pose_to_np(pose):
    x = pose.position.x
    y = pose.position.y
    yaw = quat_to_yaw(pose.orientation)
    return np.array([x, y, yaw])

# Node that uses move_base for path planning and NMPC for trajectory tracking
class MoveBaseNMPCTracker:
    def __init__(self):
        rospy.init_node("movebase_nmpc_tracker")

        # Load parameters from the parameter server
        self.map_frame = rospy.get_param("~map_frame", "map")
        # Topic for the global plan generated by move_base (can be remapped in the launch file)
        self.global_plan_topic = rospy.get_param("~global_plan_topic", "/move_base/TrajectoryPlannerROS/local_plan")
        self.vel_ref = rospy.get_param("~vel_ref", 1.5)
        self.xy_tol = rospy.get_param("~xy_tol", 0.1)
        self.rot_tol = np.deg2rad(rospy.get_param("~rot_tol_deg", 10))
        self.rate_hz = rospy.get_param("~rate", 20)
        self.initial_state = np.array(rospy.get_param("~initial_state", [0.0, 0.0, 0.0]))

        # Vehicle dynamics and control parameters
        self.max_lin_acc = rospy.get_param("~max_lin_acc", 1.0)
        self.max_ang_acc = rospy.get_param("~max_ang_acc", 0.5)
        self.max_lin_vel = rospy.get_param("~max_lin_vel", 1.0)
        self.max_ang_vel = rospy.get_param("~max_ang_vel", 1.0)
        self.vel_penalty = rospy.get_param("~vel_penalty", 0.0)

        # NMPC parameters
        self.N = rospy.get_param("~N", 30)
        self.T = rospy.get_param("~T", 0.05)
        Q_list = rospy.get_param("~Q", [5, 5, 1])
        R_list = rospy.get_param("~R", [0.2, 0.2])
        self.Q = np.diag(Q_list)
        self.R = np.diag(R_list)

        self.use_kalman_filter = rospy.get_param("~use_kalman_filter", True)
        self.kalman_Q = np.eye(3) * 0.1
        self.kalman_R = np.eye(3) * 0.1

        params = {
            "Q": self.Q,
            "R": self.R,
            "initial_state": self.initial_state,
            "max_lin_acc": self.max_lin_acc,
            "max_ang_acc": self.max_ang_acc,
            "max_lin_vel": self.max_lin_vel,
            "max_ang_vel": self.max_ang_vel,
            "vel_ref": self.vel_ref,
            "vel_penalty": self.vel_penalty,
            "kalman_Q": self.kalman_Q,
            "kalman_R": self.kalman_R,
            "use_kalman_filter": self.use_kalman_filter,
        }
        # Initialize the NMPC controller
        self.nmpc_controller = AutonomousCarNMPC(T=self.T, N=self.N, param=params)

        # Initialize PID controllers for yaw alignment
        self.yaw_pid = PIDController(kp=2.0, ki=0.0, kd=0.1, max_output=1.0)
        self.pos_pid = PIDController(kp=1.0, ki=0.0, kd=0.1, max_output=1.0)

        # State variables
        self.current_pose = None  # Current pose [x, y, yaw]
        self.global_plan = None   # Global plan from move_base
        self.fsm_state = FSMState.IDLE

        # ROS publishers and subscribers
        self.cmd_vel_pub = rospy.Publisher("/cmd_vel", Twist, queue_size=1)
        # Subscribe to move_base's global plan
        self.global_plan_sub = rospy.Subscriber(self.global_plan_topic, Path, self.global_plan_callback)
        # Subscribe to pose information (e.g., AMCL)
        self.amcl_sub = rospy.Subscriber("/amcl_pose", PoseWithCovarianceStamped, self.amcl_pose_callback)
        # Optionally subscribe to move_base's velocity commands to ignore them if needed
        # self.movebase_cmd_vel_sub = rospy.Subscriber("/move_base/cmd_vel", Twist, self.ignore_cmd_vel)

        rospy.loginfo("MoveBase NMPC Tracker node started: using move_base for path planning and NMPC for velocity control.")

    # Optionally ignore move_base velocity commands
    def ignore_cmd_vel(self, msg):
        pass

    # Callback for updating the current pose from localization
    def amcl_pose_callback(self, msg):
        self.current_pose = np.array([
            msg.pose.pose.position.x,
            msg.pose.pose.position.y,
            quat_to_yaw(msg.pose.pose.orientation)
        ])

    # Callback to receive the global plan from move_base
    def global_plan_callback(self, msg):
        self.global_plan = msg
        rospy.loginfo("Received global plan with %d poses.", len(msg.poses))
        if self.fsm_state == FSMState.IDLE:
            rospy.loginfo("State transition: IDLE -> ROTATE_TO_TRAJECTORY.")
            self.fsm_state = FSMState.ROTATE_TO_TRAJECTORY

    # Extract a local reference trajectory from the global plan
    def get_local_ref_path(self):
        if self.global_plan is None or self.current_pose is None:
            return None

        poses = self.global_plan.poses
        if len(poses) == 0:
            rospy.logwarn("Global plan is empty; cannot extract local reference trajectory.")
            return None

        # Find the closest point in the plan to the current pose
        min_dist = float("inf")
        nearest_idx = 0
        for i, pose_st in enumerate(poses):
            p = pose_to_np(pose_st.pose)
            dist = np.linalg.norm(p[:2] - self.current_pose[:2])
            if dist < min_dist:
                min_dist = dist
                nearest_idx = i

        # Extract the next N+1 poses; if not enough, repeat the last pose
        local_poses = poses[nearest_idx:nearest_idx + self.N + 1]
        if len(local_poses) == 0:
            rospy.logwarn("Unable to extract any poses from the global plan.")
            return None

        if len(local_poses) < self.N + 1:
            while len(local_poses) < self.N + 1:
                local_poses.append(local_poses[-1])
        ref_path = [pose_to_np(ps.pose) for ps in local_poses]
        return np.array(ref_path)

    # Compute the velocity command using the NMPC controller based on the reference trajectory
    def compute_cmd_vel(self, ref_path):
        if ref_path is None or self.current_pose is None:
            return None

        current_u = (self.nmpc_controller.U_opt[0, :] if self.nmpc_controller.U_opt.size 
                     else np.zeros(self.nmpc_controller.control_dim))
        if self.use_kalman_filter:
            current_state = self.nmpc_controller.kalman_update(current_u, self.current_pose)
        else:
            current_state = self.current_pose

        u = self.nmpc_controller.solve_nmpc(current_state, ref_path, current_u)
        cmd = Twist()
        cmd.linear.x = u[0]
        cmd.angular.z = u[1]
        return cmd

    # Main loop: execute control logic based on the current FSM state
    def run(self):
        rate = rospy.Rate(self.rate_hz)
        while not rospy.is_shutdown():
            if self.current_pose is None:
                rospy.logwarn("Current pose information missing.")
                rate.sleep()
                continue

            rospy.loginfo("Current state: %s", self.fsm_state.name)

            if self.fsm_state == FSMState.ROTATE_TO_TRAJECTORY:
                ref_path = self.get_local_ref_path()
                if ref_path is None:
                    rospy.logwarn("No reference trajectory obtained in ROTATE_TO_TRAJECTORY state.")
                    rate.sleep()
                    continue
                # Compute desired initial yaw from the first two points
                desired_yaw = math.atan2(ref_path[1, 1] - ref_path[0, 1],
                                         ref_path[1, 0] - ref_path[0, 0])
                yaw_error = desired_yaw - self.current_pose[2]
                yaw_error = math.atan2(math.sin(yaw_error), math.cos(yaw_error))
                rospy.loginfo("Desired yaw: %.2f, current yaw: %.2f, error: %.2f", desired_yaw, self.current_pose[2], yaw_error)
                if abs(yaw_error) < self.rot_tol:
                    rospy.loginfo("Aligned with the initial trajectory heading.")
                    self.fsm_state = FSMState.MPC_TRACKING
                else:
                    twist = Twist()
                    twist.linear.x = 0.0
                    twist.angular.z = self.yaw_pid.compute(yaw_error, 1.0 / self.rate_hz)
                    rospy.loginfo("Publishing rotation command: angular.z=%.2f", twist.angular.z)
                    self.cmd_vel_pub.publish(twist)
                    rate.sleep()
                    continue

            elif self.fsm_state == FSMState.MPC_TRACKING:
                ref_path = self.get_local_ref_path()
                if ref_path is None:
                    rospy.logwarn("No reference trajectory obtained in MPC_TRACKING state.")
                    rate.sleep()
                    continue
                cmd = self.compute_cmd_vel(ref_path)
                if cmd is not None:
                    rospy.loginfo("Publishing NMPC command: linear.x=%.2f, angular.z=%.2f", cmd.linear.x, cmd.angular.z)
                    self.cmd_vel_pub.publish(cmd)
                else:
                    rospy.logwarn("Computed velocity command is empty.")
                # Additional state transition logic can be added here if needed

            elif self.fsm_state == FSMState.ROTATE_TO_DEFAULT:
                default_yaw = rospy.get_param("~default_final_yaw", 0.0)
                yaw_error = default_yaw - self.current_pose[2]
                yaw_error = math.atan2(math.sin(yaw_error), math.cos(yaw_error))
                rospy.loginfo("Final rotation: target yaw=%.2f, current yaw=%.2f, error=%.2f", default_yaw, self.current_pose[2], yaw_error)
                if abs(yaw_error) < self.rot_tol:
                    rospy.loginfo("Final alignment complete. Vehicle is now aligned.")
                    self.cmd_vel_pub.publish(Twist())  # Stop the vehicle
                    self.fsm_state = FSMState.IDLE
                else:
                    twist = Twist()
                    twist.linear.x = 0.0
                    twist.angular.z = self.yaw_pid.compute(yaw_error, 1.0 / self.rate_hz)
                    rospy.loginfo("Publishing final rotation command: angular.z=%.2f", twist.angular.z)
                    self.cmd_vel_pub.publish(twist)

            elif self.fsm_state == FSMState.IDLE:
                # Stop the vehicle in IDLE state
                self.cmd_vel_pub.publish(Twist())

            rate.sleep()

if __name__ == '__main__':
    try:
        tracker = MoveBaseNMPCTracker()
        tracker.run()
    except rospy.ROSInterruptException:
        pass
